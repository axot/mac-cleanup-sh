#!/usr/bin/env bash

set -E
trap cleanup SIGINT SIGTERM ERR EXIT

cleanup() {
	trap - SIGINT SIGTERM ERR EXIT
}

# Default arguments
update=false

usage() {
	cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-v] [-u]

Available options:

-h, --help       Print this help and exit
-d, --dry-run    Print approx space to be cleaned
-v, --verbose    Print script debug info
-u, --update     Run brew update
EOF
	exit
}

# shellcheck disable=SC2034  # Unused variables left for readability
setup_colors() {
	if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
		NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
	else
		NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
	fi
}

msg() {
  if [ -z "$dry_run" ]; then
	  echo >&2 -e "${1-}"
	fi
}

die() {
	local msg=$1
	local code=${2-1} # default exit status 1
	msg "$msg"
	exit "$code"
}

parse_params() {
	# default values of variables set from params
	update=false

	while :; do
		case "${1-}" in
		-h | --help) usage ;;
		-v | --verbose) set -x ;;
		-d | --dry-run) dry_run=true ;;
		--no-color) NO_COLOR=1 ;;
		-u | --update) update=true ;; # update flag
		-n) true ;;                   # This is a legacy option, now default behaviour
		-?*) die "Unknown option: $1" ;;
		*) break ;;
		esac
		shift
	done

	return 0
}

parse_params "$@"
setup_colors

deleteCaches() {
	local cacheName=$1
	shift
	local paths=("$@")
	echo "Initiating cleanup ${cacheName} cache..."
	for folderPath in "${paths[@]}"; do
		if [[ -d ${folderPath} ]]; then
			dirSize=$(du -hs "${folderPath}" | awk '{print $1}')
			echo "Deleting ${folderPath} to free up ${dirSize}..."
			rm -rfv "${folderPath}"
		fi
	done
}

bytesToHuman() {
	b=${1:-0}
	d=''
	s=1
	S=(Bytes {K,M,G,T,E,P,Y,Z}iB)
	while ((b > 1024)); do
		d="$(printf ".%02d" $((b % 1024 * 100 / 1024)))"
		b=$((b / 1024))
		((s++))
	done
	if [ -z "$dry_results" ]; then
    msg "$b$d ${S[$s]} of space was cleaned up"
  else
    msg "Approx $b$d ${S[$s]} of space will be cleaned up"
  fi
}

count_dry() {
  for path in "${path_list[@]}"; do
    if [ -d "$path" ] || [ -f "$path" ]; then
      temp_dry_results=$(sudo du -ck "$path" | tail -1 | awk '{ print $1 }')
      dry_results="$((dry_results+temp_dry_results))"
    fi
  done
}

remove_paths() {
  if [ -z "$dry_run" ]; then
    for path in "${path_list[@]}"; do
      rm -rfv "$path" &>/dev/null
    done
    unset path_list
  fi
}

collect_paths() {
  path_list+=("$@")
}

# Ask for the administrator password upfront
sudo -v

HOST=$(whoami)

# Keep-alive sudo until `mac-cleanup.sh` has finished
while true; do
	sudo -n true
	sleep 60
	kill -0 "$$" || exit
done 2>/dev/null &

# Enable extended regex
shopt -s extglob

oldAvailable=$(df / | tail -1 | awk '{print $4}')

collect_paths /Library/Caches/*
collect_paths /System/Library/Caches/*
collect_paths ~/Library/Caches/*
msg 'Clearing System Cache Files...'
remove_paths

collect_paths /private/var/log/asl/*.asl
collect_paths /Library/Logs/*/*
collect_paths /private/var/db/diagnostics/*
msg 'Clearing System Log Files...'
remove_paths

collect_paths /usr/local/amazon/var/acme/cache
collect_paths /opt/homebrew/Caskroom
collect_paths /opt/amazon-kinesistap/var/update
collect_paths $HOME/.cache/*
collect_paths $HOME/Library/Caches/*
msg 'Clearing Other Cache Files...'
remove_paths

collect_paths $HOME/.claude/projects
collect_paths $HOME/.claude/todos
collect_paths $HOME/.claude/shell-snapshot
collect_paths $HOME/.claude/statsig
msg 'Clearing Claude Code Files...'
remove_paths

if [ -d ~/Library/Application\ Support/Google/Chrome/ ]; then
  collect_paths ~/Library/Application\ Support/Google/Chrome/Default/WebStorage/*
  collect_paths ~/Library/Application\ Support/Google/Chrome/Default/Service\ Worker/CacheStorage/*
  collect_paths ~/Library/Application\ Support/Google/Chrome/component_crx_cache
  collect_paths ~/Library/Caches/Google/Chrome/Default/Cache
  msg 'Clearing Google Chrome Cache Files...'
  remove_paths
fi

if type "brew" &>/dev/null; then
  collect_paths "$(brew --cache)"
  msg 'Cleaning up Homebrew Cache...'
  if [ -z "$dry_run" ]; then
    brew cleanup -s &>/dev/null
    remove_paths
    brew tap --repair &>/dev/null
  else
    remove_paths
  fi
fi

if type "docker" &>/dev/null; then  # TODO add count_dry
  if [ -z "$dry_run" ]; then
    if ! docker ps >/dev/null 2>&1; then
      close_docker=true
      open --background -a Docker
    fi
    msg 'Cleaning up Docker'
    docker system prune -af &>/dev/null
    if [ "$close_docker" = true ]; then
      killall Docker
    fi
  fi
fi

if [ "$PYENV_VIRTUALENV_CACHE_PATH" ]; then
  collect_paths "$PYENV_VIRTUALENV_CACHE_PATH"
  msg 'Removing Pyenv-VirtualEnv Cache...'
  remove_paths
fi

if type "npm" &>/dev/null; then
  if [ -z "$dry_run" ]; then
    msg 'Cleaning up npm cache...'
    npm cache clean --force &>/dev/null
  else
    collect_paths ~/.npm/*
  fi
fi

if type "yarn" &>/dev/null; then
  if [ -z "$dry_run" ]; then
    msg 'Cleaning up Yarn Cache...'
    yarn cache clean --force &>/dev/null
  else
    collect_paths ~/Library/Caches/yarn
  fi
fi

if type "pnpm" &>/dev/null; then
  if [ -z "$dry_run" ]; then
    msg 'Cleaning up pnpm Cache...'
    pnpm store prune &>/dev/null
  else
    collect_paths ~/.pnpm-store/*
  fi
fi

if type "pod" &>/dev/null; then
  if [ -z "$dry_run" ]; then
    msg 'Cleaning up Pod Cache...'
    pod cache clean --all &>/dev/null
  else
    collect_paths ~/Library/Caches/CocoaPods
  fi
fi

if type "go" &>/dev/null; then
  if [ -z "$dry_run" ]; then
    msg 'Clearing Go module cache...'
    go clean -modcache &>/dev/null
  else
    if [ -n "$GOPATH" ]; then
      collect_paths "$GOPATH/pkg/mod"
    else
      collect_paths ~/go/pkg/mod
    fi
  fi
fi

# Disables extended regex
# shopt -u extglob

PASS=`security find-generic-password -a ${USER} -s brew_cu -w`
sudo -S -v <<< $PASS

if [ -z "$dry_run" ]; then
  msg "${GREEN}Success!${NOFORMAT}"

  newAvailable=$(df / | tail -1 | awk '{print $4}')
  count=$((newAvailable - oldAvailable))
  bytesToHuman $count
  cleanup
else
  count_dry
  unset dry_run
  bytesToHuman "$dry_results"
  msg "Continue? [enter]"
  read -r -s -n 1 clean_dry_run
  if [[ $clean_dry_run = "" ]]; then
    if [ "$update" = true ]; then
      exec "$0" --update
    else
      exec "$0"
    fi
  fi
  cleanup
fi
